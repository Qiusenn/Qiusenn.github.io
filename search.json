[{"title":"glup报错解决","date":"2021-12-24T16:51:11.000Z","url":"/2021/12/25/glup%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/","categories":[["gulp","/categories/gulp/"]],"content":"测试页面，运行gulp的报错解决 关于错误： 首先查看gulp的版本:可以看出当前gulp版本为4 Gulp 4 中需要使用 gulp.series (顺序执行) 和gulp paralle(并行计算)，因为gulp任务现在只有两个参数，第二个参数必须为函数。所以将数组修改为顺序执行函数,在gulpfile.js文件夹下修改： "},{"title":"rem适配js代码","date":"2021-12-24T16:18:10.000Z","url":"/2021/12/25/rem%E9%80%82%E9%85%8Djs%E4%BB%A3%E7%A0%81/","categories":[["rem适配","/categories/rem%E9%80%82%E9%85%8D/"]],"content":" rem适配 rem是指相对于根元素（html）的字体大小的单位，它是一个相对单位，它是css3新增加的一个单位属性，我们现在有很多人用的都是px,但px是一个绝对单位，遇到分辨率不同的设备，做出的页面可能会乱，这就给我们造成了很大的影响，而且后期的修复也很费时间，所以rem是一个很不错的适配方法。rem的初始值是16px，也就是说在没有设置根节点的font-size的时候，1rem=16px；我们现在需要设置1rem = 100px 在header或文件引入当前代码 在cssrem设置1rem = 100px"},{"title":"flow类型注解","date":"2021-12-23T16:32:14.000Z","url":"/2021/12/24/flow%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3/","categories":[["TS","/categories/TS/"]],"content":"flow 类型验证使用初始化 在当前文件或项目下安装 flow 依赖 在js文件使用使用之前先关闭js的语法监测 (用于将提示波浪线关闭) 设置&gt;搜索javascript validate 取消勾选 js 语法监测 初始化flow包 生成配置文件 .flowconfig文件 当代码书写完毕 进行语法监测 错误会在控制台进行打印，便于查看错误原因 安装flow提供的包来进行转化 对ts文件进行打包并生成在当前dist文件下 生成的文件内 类似此语法 "},{"title":"函数参数的默认值","date":"2021-12-23T15:32:00.000Z","url":"/2021/12/23/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC/","categories":[["JS","/categories/JS/"]],"content":" 1.函数参数的默认值 在es6之前，不能直接为函数的参数指定默认值，只能采用变通的方法。 上面代码的弊端：如果参数 y 没有被赋值 则默认为 Word 但是给 y 赋值为 &#39;&#39; 空字符串时却还是默认赋值为Word 因为空字符串 &#39;&#39; 被判断为 false 所以赋值为 Word 所以为了避免这个问题 通常需要先判断 y 是否有被赋值，如果没有再等于默认值 ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。 上面代码中，参数变量x是默认声明的，在函数体中，不能用let或const再次声明，否则会报错。 使用参数默认值时，函数不能有同名参数。 参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。 上面代码中，参数k的默认值是x + 1。这时，每次调用函数foo，都会重新计算x + 1，而不是默认k等于 100。 与解构赋值默认值结合使用"},{"title":"关于 package.json 文件","date":"2021-12-23T15:32:00.000Z","url":"/2021/12/23/package%20%E8%AF%A6%E8%A7%A3/","categories":[["npm","/categories/npm/"]],"content":"package.json 文件 package.json 文件是项目的清单。 它可以做很多完全互不相关的事情。 例如，它是用于工具的配置中心。 它也是 npm 和 yarn 存储所有已安装软件包的名称和版本的地方。另外在 package.json 文件中需遵循 json 格式 文件结构这是一个简单的package.json: 它定义了 name 属性，用于告知应用程序或软件包的名称。 这是一个更复杂的示例，该示例是从 Vue.js 应用程序示例中提取的： 这里有很多依赖等相关配置 version 表明了当前的版本。 name 设置了应用程序/软件包的名称。 description 是应用程序/软件包的简短描述。 main 设置了应用程序的入口点。 private 如果设置为 true，则可以防止应用程序/软件包被意外地发布到 npm。 scripts 定义了一组可以运行的 node 脚本。 dependencies 设置了作为依赖安装的 npm 软件包的列表。 devDependencies 设置了作为开发依赖安装的 npm 软件包的列表。 engines 设置了此软件包/应用程序在哪个版本的 Node.js 上运行。 browserslist 用于告知要支持哪些浏览器（及其版本）。 还有其他属性 bugs 链接到软件包的问题跟踪器，最常用的是 GitHub 的 issues 页面。 homepage 软件包的主页。 version 软件包的相应版本 此属性遵循版本的语义版本控制记法，这意味着版本始终以 3 个数字表示：x.x.x。"},{"title":"单向数据流","date":"2021-12-19T12:49:39.000Z","url":"/2021/12/19/%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81/","categories":[["Vue","/categories/Vue/"]],"content":" Vue 单向数据流 所有的 prop 都使得其父子 prop 之前形成了一个单向下行组件绑定: 父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件以外的改变父组件的状态。从而导致你的应用的数据流难以理解。 额外的，每次父组件发生更新时，子组件中所有的 prop 都会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop 。如果你这样做了，Vue会在浏览器的控制台中发出警告。 子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，有父组件修改。 两种常见的试图改变一个 prop 的情形 这个 prop 用来传递一个初始值; 这个子组件接下来希望将作为一个本地的 prop数据来使用。在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值。 这个 prop 以一种原始的值传入且需要进行转换。 在这种情况下，最好使用这个 prop 的值来定义一个计算属性。 "},{"title":"spa单页面","date":"2021-12-19T12:17:18.000Z","url":"/2021/12/19/spa%E5%8D%95%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81/","categories":[["Vue","/categories/Vue/"]],"content":" SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。 优点 用户体验好、块，内容的改变不需要加载整个页面，避免了不必要的跳转和重复渲染; 基于上面一点，SPA相对于服务器压力小 前后端职责分离，架构清晰，前端进行交互逻辑。后端负责数据处理 缺点 初次加载耗时较多: 为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将JavaScript、CSS 统一加载，部分页面按需加载; 前进后退路由管理: 由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能。所有的页面切换需要自己简历堆栈管理; SEO 难度较大: 由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。 "}]