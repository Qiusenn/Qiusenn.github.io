[{"title":"Redux","date":"2022-02-23T15:47:23.000Z","url":"/2022/02/23/Redux/","categories":[["React","/categories/React/"]],"content":"redux Redux 是 JavaScript 状态容器，提供可预测化的状态管理。 安装: 创建一个简单的store： let store = createStore(counter) 打印store看看 dispacth (用于提交action) getState (用于获取store数据) subScribe (用于监听store数据的变化) dispatch 提交修改store内数据 getState (用于获取store数据) subScribe (用于监听store数据的变化,数据变化执行回调) 当出现多个需要store的数据时，使用 combineReducers reducer数据: onther数据: 将两个数据合并： "},{"title":"装饰器","date":"2022-02-23T15:45:55.000Z","url":"/2022/02/23/%E8%A3%85%E9%A5%B0%E5%99%A8/","categories":[["TS","/categories/TS/"]],"content":"装饰器 装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上。 装饰器使用 @expression这种形式，expression求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。 装饰器工厂如果我们要定制一个修饰器如何应用到一个声明上，我们得写一个装饰器工厂函数。 装饰器工厂就是一个简单的函数，它返回一个表达式，以供装饰器在运行时调用。 我们可以通过下面的方式来写一个装饰器工厂函数： 装饰器组合多个装饰器可以同时应用到一个声明上:当多个装饰器应用在一个声明上时会进行如下步骤的操作： 由上至下依次对装饰器表达式求值。 求值的结果会被当作函数，由下至上依次调用。 过下面的例子来观察它们求值的顺序： 执行结果 类装饰器 当@sealed被执行的时候，它将密封此类的构造函数和原型 方法装饰器方法装饰器表达式会在运行时当作函数被调用，传入下列3个参数： 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。 成员的名字。 成员的属性描述符。注意 如果代码输出目标版本小于ES5，属性描述符将会是undefined。 下面是一个方法装饰器（@enumerable）的例子，应用于Greeter类的方法上： 属性装饰器属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数： 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。 成员的名字。 属性描述符不会做为参数传入属性装饰器，这与TypeScript是如何初始化属性装饰器的有关。 因为目前没有办法在定义一个原型对象的成员时描述一个实例属性，并且没办法监视或修改一个属性的初始化方法。返回值也会被忽略。因此，属性描述符只能用来监视类中是否声明了某个名字的属性。 "},{"title":"Provide Inject API使用","date":"2022-02-15T14:23:38.000Z","url":"/2022/02/15/Provide-Inject-API%E4%BD%BF%E7%94%A8/","categories":[["Vue3","/categories/Vue3/"]],"content":"Provide Inject在绝大多数情况下，不鼓励使用全局的事件总线在组件之间进行通信。虽然在短期内往往是最简单的解决方案，但从长期来看，它维护起来总是令人头疼。根据具体情况来看，有多种事件总线的替代方案其中一个就是provide inject： Provide 和 inject 允许一个组件与它的插槽内容进行通信。这对于总是一起使用的紧密耦合的组件非常有用。 provide/inject 也能够用于组件之间的远距离通信。它可以帮助避免“prop 逐级透传”，即 prop 需要通过许多层级的组件传递下去，但这些组件本身可能并不需要那些 prop。 注： 两者都只能在当前活动实例的 setup() 期间调用。 使用 Provide 使用 inject 子孙组件更改provide数据提供一个更改数据的函数： "},{"title":"script-setup单文件组件语法糖","date":"2022-02-14T14:43:33.000Z","url":"/2022/02/14/script-setup%E5%8D%95%E6%96%87%E4%BB%B6%E7%BB%84%E4%BB%B6%E8%AF%AD%E6%B3%95%E7%B3%96/","categories":[["Vue3","/categories/Vue3/"]],"content":"&lt;script setup&gt; 单文件组件语法糖&lt;script setup&gt; 是在单文件组件 (SFC) 中使用 组合式 API 的编译时语法糖。相比于普通的 &lt;script&gt; 语法，它具有更多优势： 更好的样板内容，更简洁的代码。 能够使用纯 TypeScript 生命 props 和抛出事件。 更好的运行时性能 (其模板会被编译成与其同一作用域的渲染函数，没有任何的中间代理)。 更好的 IDE 类型推断性能 (减少语言服务器从代码中抽离类型的工作)。 基本语法 将 setup attribute 添加到 &lt;script&gt; 代码块上: 里面的代码会被编译成组件 setup() 函数的内容。和普通 &lt;script&gt; 标签不同， &lt;script setup&gt; 中的代码会在每次组件实例被创建的时候执行。 顶层的绑定会被暴露给模板当使用 &lt;script setup&gt; 的时候，任何在 &lt;script setup&gt; 声明的顶层的绑定 (包括变量，函数声明，以及 import 引入的内容) 都能在模板中直接使用： 也可以直接 import 导入定义好的js文件工具函数，并且可以直接在模板中直接使用导入的 helper 函数，并不需要通过 methods 选项来暴露它： 响应式 使用响应式数据需要引用 ref , ref 值在模板中使用的时候会自动解包(当数据更新页面数据也需要同步更新时用 ref()包裹 ，若为引用类型数据时用 reactive() 包裹)： 使用组件 &lt;script setup&gt; 范围里的值也能被直接作为自定义组件的标签名使用,不需要在 components 内注册： defineProps 、 defineEmits 、 defineExpose 在 &lt;script setup&gt; 中必须使用 defineProps 和 defineEmits API 来声明 props 和 emits 使用 &lt;script setup&gt; 的组件是默认关闭的，也即通过模板 ref 或者 $parent 链获取到的组件的公开实例，不会暴露任何在 &lt;script setup&gt; 中声明的绑定。 为了在 &lt;script setup&gt; 组件中明确要暴露出去的属性，使用 defineExpose 编译器宏： "},{"title":"Vue3 v-model","date":"2022-02-14T14:41:26.000Z","url":"/2022/02/14/Vue3-v-model/","categories":[["Vue3","/categories/Vue3/"]],"content":"关于 Vue3 对 v-model 的语法(实现组件双向绑定) Vue2.x 语法在 2.x中，在组件上使用 v-model 相当于绑定 value prop 并触发 input 事件： 使用 v-bind.sync某些情况下需要对一个 prop 进行 “双向绑定” ，通常使用 update:myPropName 抛出一个自定义事件。 方便起见，一般会对上面父组件使用 .sync 修饰符来缩写： Vue3.x 语法在 3.x 中，自定义组件上的 v-model 相当于传递了 modelValue prop 并接收抛出的 update:modelValue 事件： v-model 参数可以为 v-model 传递一个参数，以作为组件内 model 选项的替代： Vue3.x prop 双向绑定 迁移策略将原有的 .sync 的部分替换为 v-model : "},{"title":"Vue3 新特性目录","date":"2022-02-13T15:56:42.000Z","url":"/2022/02/13/Vue3-%E6%96%B0%E7%89%B9%E6%80%A7%E7%9B%AE%E5%BD%95/","categories":[["Vue3","/categories/Vue3/"]],"content":"一、简介2020年9月18日,Vue.js发布3.0版本,代号: One Piece(海贼王) 新事物的出现一定会有他的意义，所以我们先来看看Vue3相比Vue2有哪些改进呢？ 1.性能的提升 打包大小减少41% 初次渲染快55% 更新渲染快133% 内存减少54% 以上数据来自官方 2.源码的升级 使用Proxy 代替 defineProperty 实现响应式 重写虚拟DOM的实现和Tree-Shaking 3.拥抱TypeScript Vue3可以更好的支持TypeScript 4.新的特性 Composition API (组合式API) setup 配置 ref 与 reactive watch 与 watchEffect provide 与 inject 2.新的内置组件 Fragment Teleport Supense 3.其他改变 新的生命周期钩子 data 选项应始终被声明为一个函数 移除 keyCode 支持作为 v-on 的修饰符 "},{"title":"相等运算符","date":"2022-02-11T14:49:00.000Z","url":"/2022/02/11/%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6/","categories":[["JS","/categories/JS/"]],"content":"相等运算符的算法细节相等运算符的总体描述，只有一句话: 相等运算符用于比较两个值，返回true或false。 首先看下面的表达式: 相等运算符算法一共有12步： 1.如果x不是正常值(比如抛出错误)，中断执行。类似使用未定义的变量进行比较(抛出错误) 2.如果y不是正常值，中断执行。 3.如果Type(x)与Type(y)相同，执行严格相等运算x === y。 4.如果x是null，y是undefined，返回true。 5.如果x是undefined，y是null，返回true。 6.如果Type(x)是数值，Type(y)是字符串，返回x == ToNumber(y)的结果。 7.如果Type(x)是字符串，Type(y)是数值，返回ToNumber(x) == y的结果。 8.如果Type(x)是布尔值，返回ToNumber(x) == y的结果。 9.如果Type(y)是布尔值，返回x == ToNumber(y)的结果。 10.如果Type(x)是字符串或数值或Symbol值，Type(y)是对象，返回x == ToPrimitive(y)的结果。 11.如果Type(x)是对象，Type(y)是字符串或数值或Symbol值，返回ToPrimitive(x) == y的结果。 12.返回false。 由于0的类型是数值，null的类型是 Null,因此上面的前 11 步都得不到结果，要到第 12 步才能得到false。 "},{"title":"egretRunBug解决","date":"2022-01-06T14:34:12.000Z","url":"/2022/01/06/egretRunBug%E8%A7%A3%E5%86%B3/","categories":[["Egret","/categories/Egret/"]],"content":"记录报错解决环境变量导致egret命令缺失 使用了 npm 安装 egret引擎 导致命令使用了 npm 的 egret 命令 for %x in (egret.cmd) do @echo %~$PATH:x找到路径删掉对应的egret.cmd文件 "},{"title":"inquirer.js命令行交互工具的使用","date":"2022-01-06T14:31:19.000Z","url":"/2022/01/06/inquirer-js%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BA%A4%E4%BA%92%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/","categories":[["undefined",""]],"content":"inquirer.js 写在前面 现在大多数工程都是通过脚手架来创建的，使用脚手架的时候最明显的就是与命令行的交互，如果想自己做一个脚手架或者在某些时候要与用户进行交互，这个时候就不得不提到inquirer.js了。 关于inquirer.js参数： type：表示提问的类型，包括：input, confirm, list, rawlist, expand, checkbox, * password, editor； name: 存储当前问题回答的变量； message：问题的描述； default：默认值； choices：列表选项，在某些type下可用，并且包含一个分隔符(separator)； validate：对用户的回答进行校验； filter：对用户的回答进行过滤处理，返回处理后的值； transformer：对用户回答的显示效果进行处理(如：修改回答的字体或背景颜色)，但不会影响* 最终的答案的内容； when：根据前面问题的回答，判断当前问题是否需要被回答； pageSize：修改某些type类型下的渲染行数； prefix：修改message默认前缀； suffix：修改message默认后缀； 使用 inquirer 关于 type 参数的使用 表单输入 input password confirm 选择 yes or no list 列表选择 数字输入选择 rawlist 自定义 key 选择 expandList checkbox 选择 多选框 备注文本框 editor 多个选择框一起使用 "},{"title":"TypeScript-泛型","date":"2021-12-30T14:00:59.000Z","url":"/2021/12/30/TypeScript-%E6%B3%9B%E5%9E%8B/","categories":[["TS","/categories/TS/"]],"content":"使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。 不使用泛型的函数是这个例子 (该函数表示传入的arg参数直接被约束为number类型，并且函数的返回值也被约束为number类型) 这样函数就没有可复用性。 再或者使用any类型来定义函数 (使用any类型会导致这个函数可以接收任何类型的arg参数，这样就丢失了一些信息：传入的类型应该与返回的类型相同。如果传入一个数字，我们只知道任何类型的值都有可能被返回) 存在返回类型不明确。 需要传入类型和返回类型相同时，使用 类型变量，它是一种特殊的变量，只用于表示类型而不是值 T。（该函数表示给identity添加类型变量T.T帮助我们捕获用户传入的类型(比如: number),之后使用这个类型，将T类型当做返回值类型。这样就能知道参数类型与返回值类型相同了。这允许我们跟踪函数里使用的类型的信息。） 我们把这个版本的identity函数叫做泛型，因为它可以适用于多个类型。 不同于使用 any，它不会丢失信息，像第一个例子那像保持准确性，传入数值类型并返回数值类型。 利用了类型推论 – 即编译器会根据传入的参数自动地帮助我们确定T的类型： 使用泛型变量如果我们想在函数中打印传入的 number 或者 string 的长度时:使用泛型创建像identity这样的泛型函数时，编译器要求你必须把这些参数当做是任意或所有类型。 为什么会报错呢? (因为没有地方指明arg具有length这个属性。 记住，这些类型变量代表的是任意类型，所以使用这个函数的人可能传入的是个数字，而数字是没有 .length属性的。) 假设传入的arg类型为数组类型时,可以这样解决： 如果是字符串时 使用泛型约束当我们知道函数中存在length属性时，为此定义一个接口来描述约束条件。创建一个包含length属性的接口，使用这个接口和extends关键字来实现约束： "},{"title":"mockjs使用","date":"2021-12-30T13:50:57.000Z","url":"/2021/12/30/mockjs%E4%BD%BF%E7%94%A8/","categories":[["mock","/categories/mock/"]],"content":"mockjs 使用 安装 axios: npm install axios --savemockjs: npm install mockjs --save 创建mock.js文件 main.js 中引入 封装axios请求拦截等.. 在页面或组件中使用 "},{"title":"gulp项目搭建","date":"2021-12-25T12:54:00.000Z","url":"/2021/12/25/gulp%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/","categories":[["gulp","/categories/gulp/"]],"content":"使用gulp搭建TypeScript 什么是 gulp? Gulp 是基于node.js的一个前端自动化构建工具，开发这可以使用它构建自动化工作流程（前端集成开发环境）。使用gulp你可以简化工作量，让你把重点放在功能的开发上，从而提高你的开发效率和工作质量。例如：你可以用gulp可以网页自动刷新，和MVVM开发模式很相似，如果你对vue.js有所了解的话，那么你一定不会陌生。你也可以使用gulp对sass进行预处理、代码检测、图片优化压缩、只需要一个简单的指令就能全部完成。 在Gulp管道里添加Browserify， uglify或Watchify。 它还包涵了 Babel的功能，通过使用Babelify。 搭建工程目录 (proj可更改为其他项目名) 初始化工程(进入proj文件，初始化完成会生成package.json文件用来更改项目配置) 安装依赖项 (全局安装TypeScript和Gulp) 安装typescript，gulp和gulp-typescript到开发依赖项。 Gulp-typescript是TypeScript的一个Gulp插件。 写一个简单的例子 (让我们写一个Hello World程序。 在 src目录下创建main.ts文件) 在工程的根目录proj下新建一个tsconfig.json文件： 新建 gulpfile.js 文件 (在工程根目录下，新建一个gulpfile.js文件：) 测试这个应用 程序应该能够打印出“Hello from TypeScript!”。 向代码里添加模块 (注意：在使用Browserify前，让我们先构建一下代码然后再添加一些混入的模块。 这个结构将是你在真实应用程序中会用到的。)新建一个src/greet.ts文件： 更改src/main.ts代码，从greet.ts导入sayHello： 最后，将src/greet.ts添加到tsconfig.json 确保执行gulp后模块是能工作的，在Node.js下进行测试 Browserify (把所有模块捆绑成一个JavaScript文件。 所幸，这正是Browserify要做的事情。 更方便的是，它支持Node.js的CommonJS模块，这也正是TypeScript默认生成的类型。 也就是说TypeScript和Node.js的设置不需要改变就可以移植到浏览器里。) 安装Browserify，tsify和vinyl-source-stream。 tsify : 是Browserify的一个插件，就像gulp-typescript一样，它能够访问TypeScript编译器。 vinyl-source-stream : 会将Browserify的输出文件适配成gulp能够解析的格式，它叫做 vinyl。 新建一个页面 (在src目录下新建一个index.html文件：) 修改main.ts文件来更新这个页面： showHello调用sayHello函数更改页面上段落的文字。 现在修改gulpfile文件如下： 这里增加了copy-html任务并且把它加作default的依赖项。 这样，当 default执行时，copy-html会被首先执行。 我们还修改了 default任务，让它使用tsify插件调用Browserify，而不是gulp-typescript。 方便的是，两者传递相同的参数对象到TypeScript编译器。 调用bundle后，我们使用source（vinyl-source-stream的别名）把输出文件命名为bundle.js。 测试此页面，运行gulp，然后在浏览器里打开dist/index.html。 你应该能在页面上看到“Hello from TypeScript”。 注意，我们为Broswerify指定了debug: true。 这会让 tsify在输出文件里生成source maps。 source maps允许我们在浏览器中直接调试TypeScript源码，而不是在合并后的JavaScript文件上调试。 你要打开调试器并在 main.ts里打一个断点，看看source maps是否能工作。 当你刷新页面时，代码会停在断点处，从而你就能够调试 greet.ts。 Watchify，Babel和Uglify现在代码已经用Browserify和tsify捆绑在一起了，我们可以使用Browserify插件为构建添加一些特性。 Watchify : 启动Gulp并保持运行状态，当你保存文件时自动编译。 帮你进入到编辑-保存-刷新浏览器的循环中。Babel : 是个十分灵活的编译器，将ES2015及以上版本的代码转换成ES5和ES3。 你可以添加大量自定义的TypeScript目前不支持的转换器。Uglify : 帮你压缩代码，将花费更少的时间去下载它们。 依次安装 :npm install --save-dev watchify gulp-utilnpm install --save-dev gulp-uglify vinyl-buffer gulp-sourcemapsnpm install --save-dev babelify babel-core babel-preset-es2015 vinyl-buffer gulp-sourcemaps 最后更改 gulpfile.js 文件为 : 运行 项目搭建成功 "},{"title":"rem适配js代码","date":"2021-12-24T16:18:10.000Z","url":"/2021/12/25/rem%E9%80%82%E9%85%8Djs%E4%BB%A3%E7%A0%81/","categories":[["rem适配","/categories/rem%E9%80%82%E9%85%8D/"]],"content":" rem适配 rem是指相对于根元素（html）的字体大小的单位，它是一个相对单位，它是css3新增加的一个单位属性，我们现在有很多人用的都是px,但px是一个绝对单位，遇到分辨率不同的设备，做出的页面可能会乱，这就给我们造成了很大的影响，而且后期的修复也很费时间，所以rem是一个很不错的适配方法。rem的初始值是16px，也就是说在没有设置根节点的font-size的时候，1rem=16px；我们现在需要设置1rem = 100px 在header或文件引入当前代码 在cssrem设置1rem = 100px"},{"title":"glup报错解决","date":"2021-12-24T16:01:06.000Z","url":"/2021/12/25/glup%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/","categories":[["gulp","/categories/gulp/"]],"content":"测试页面，运行gulp的报错解决 关于错误： 首先查看gulp的版本:可以看出当前gulp版本为4 Gulp 4 中需要使用 gulp.series (顺序执行) 和gulp paralle(并行计算)，因为gulp任务现在只有两个参数，第二个参数必须为函数。所以将数组修改为顺序执行函数,在gulpfile.js文件夹下修改： "},{"title":"flow类型注解","date":"2021-12-23T16:32:14.000Z","url":"/2021/12/24/flow%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3/","categories":[["TS","/categories/TS/"]],"content":"flow 类型验证使用初始化 在当前文件或项目下安装 flow 依赖 在js文件使用使用之前先关闭js的语法监测 (用于将提示波浪线关闭) 设置&gt;搜索javascript validate 取消勾选 js 语法监测 初始化flow包 生成配置文件 .flowconfig文件 当代码书写完毕 进行语法监测 错误会在控制台进行打印，便于查看错误原因 安装flow提供的包来进行转化 对ts文件进行打包并生成在当前dist文件下 生成的文件内 类似此语法 "},{"title":"函数参数的默认值","date":"2021-12-23T15:32:00.000Z","url":"/2021/12/23/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC/","categories":[["JS","/categories/JS/"]],"content":" 1.函数参数的默认值 在es6之前，不能直接为函数的参数指定默认值，只能采用变通的方法。 上面代码的弊端：如果参数 y 没有被赋值 则默认为 Word 但是给 y 赋值为 &#39;&#39; 空字符串时却还是默认赋值为Word 因为空字符串 &#39;&#39; 被判断为 false 所以赋值为 Word 所以为了避免这个问题 通常需要先判断 y 是否有被赋值，如果没有再等于默认值 ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。 上面代码中，参数变量x是默认声明的，在函数体中，不能用let或const再次声明，否则会报错。 使用参数默认值时，函数不能有同名参数。 参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。 上面代码中，参数k的默认值是x + 1。这时，每次调用函数foo，都会重新计算x + 1，而不是默认k等于 100。 与解构赋值默认值结合使用"},{"title":"关于 package.json 文件","date":"2021-12-23T15:32:00.000Z","url":"/2021/12/23/package%20%E8%AF%A6%E8%A7%A3/","categories":[["npm","/categories/npm/"]],"content":"package.json 文件 package.json 文件是项目的清单。 它可以做很多完全互不相关的事情。 例如，它是用于工具的配置中心。 它也是 npm 和 yarn 存储所有已安装软件包的名称和版本的地方。另外在 package.json 文件中需遵循 json 格式 文件结构这是一个简单的package.json: 它定义了 name 属性，用于告知应用程序或软件包的名称。 这是一个更复杂的示例，该示例是从 Vue.js 应用程序示例中提取的： 这里有很多依赖等相关配置 version 表明了当前的版本。 name 设置了应用程序/软件包的名称。 description 是应用程序/软件包的简短描述。 main 设置了应用程序的入口点。 private 如果设置为 true，则可以防止应用程序/软件包被意外地发布到 npm。 scripts 定义了一组可以运行的 node 脚本。 dependencies 设置了作为依赖安装的 npm 软件包的列表。 devDependencies 设置了作为开发依赖安装的 npm 软件包的列表。 engines 设置了此软件包/应用程序在哪个版本的 Node.js 上运行。 browserslist 用于告知要支持哪些浏览器（及其版本）。 还有其他属性 bugs 链接到软件包的问题跟踪器，最常用的是 GitHub 的 issues 页面。 homepage 软件包的主页。 version 软件包的相应版本 此属性遵循版本的语义版本控制记法，这意味着版本始终以 3 个数字表示：x.x.x。"},{"title":"单向数据流","date":"2021-12-19T12:49:39.000Z","url":"/2021/12/19/%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81/","categories":[["Vue","/categories/Vue/"]],"content":" Vue 单向数据流 所有的 prop 都使得其父子 prop 之前形成了一个单向下行组件绑定: 父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件以外的改变父组件的状态。从而导致你的应用的数据流难以理解。 额外的，每次父组件发生更新时，子组件中所有的 prop 都会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop 。如果你这样做了，Vue会在浏览器的控制台中发出警告。 子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，有父组件修改。 两种常见的试图改变一个 prop 的情形 这个 prop 用来传递一个初始值; 这个子组件接下来希望将作为一个本地的 prop数据来使用。在这种情况下，最好定义一个本地的 data 属性并将这个 prop 用作其初始值。 这个 prop 以一种原始的值传入且需要进行转换。 在这种情况下，最好使用这个 prop 的值来定义一个计算属性。 "},{"title":"spa单页面","date":"2021-12-19T12:17:18.000Z","url":"/2021/12/19/spa%E5%8D%95%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81/","categories":[["Vue","/categories/Vue/"]],"content":" SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。 优点 用户体验好、块，内容的改变不需要加载整个页面，避免了不必要的跳转和重复渲染; 基于上面一点，SPA相对于服务器压力小 前后端职责分离，架构清晰，前端进行交互逻辑。后端负责数据处理 缺点 初次加载耗时较多: 为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将JavaScript、CSS 统一加载，部分页面按需加载; 前进后退路由管理: 由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能。所有的页面切换需要自己简历堆栈管理; SEO 难度较大: 由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。 "}]